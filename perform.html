<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Ceiling Performance</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: #000; overflow: hidden; cursor: none; }
  canvas { display: block; }
  #loading {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    color: white; font: 24px monospace; z-index: 20;
    text-align: center; line-height: 1.6;
  }
  #hud {
    position: fixed; top: 10px; left: 10px;
    color: #0f0; font: 12px monospace;
    background: rgba(0,0,0,0.7); padding: 8px 12px;
    border-radius: 4px; pointer-events: none; z-index: 10;
    display: none;
  }
</style>
</head>
<body>
<div id="loading">Loading...</div>
<canvas id="canvas"></canvas>
<div id="hud"></div>

<script>
// ============================================================
// CONSTANTS
// ============================================================
let IMG_W = 2731, IMG_H = 2048; // updated per scene from bgImage dimensions
const ASPECT = 16 / 9;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const hud = document.getElementById('hud');
const loadingEl = document.getElementById('loading');

// ============================================================
// CONFIG (merged from config.json global + movement override)
// ============================================================
let masterConfig = null;
let config = {
  dimLevel: 0.15,
  litLevel: 1.00,
  defaultFadeIn: 200,
  defaultFadeOut: 500,
  sparkleMinOn: 20,
  sparkleMaxOn: 80,
  sparkleMinOff: 20,
  sparkleMaxOff: 80,
  litSaturate: 1.8,
  litContrast: 1.3,
  sceneFadeDuration: 1000,
  crossfadeDuration: 1500
};

// ============================================================
// STATE
// ============================================================
// Movement / scene navigation
let movementIdx = -1;       // currently loaded movement (0-indexed)
let sceneIdx = 0;           // current scene within movement
let loadedScenes = [];      // array of scene data objects
let isLoading = false;
let awaitingEnter = false;  // after loading, waiting for Enter to fade in

// Current scene's render data (set from loadedScenes[sceneIdx])
let bgImage = null;
let idMapData = null;
let idMapW = IMG_W, idMapH = IMG_H;
let regionMeta = null;
let regionRuns = {};
let groups = {};
let sequences = {};

// View (16:9 crop of the image)
let view = { x: 0, y: 0, w: IMG_W, h: IMG_W / ASPECT };

// Sequence key states: keyChar -> seqState
let seqStates = {};

// Crossfade between scenes
let xfadeActive = false;
let xfadeFromBg = null;     // bgImage of the "from" scene
let xfadeFromImgW = 2731, xfadeFromImgH = 2048; // dimensions of the from-scene image
let xfadeAlpha = 0;         // 0 = from scene, 1 = to scene
let xfadeStart = null;

// Global scene fade (0 = black, 1 = visible)
let sceneFade = 0;
let sceneFadeTarget = 0;
let sceneFadeStart = null;
let sceneFadeFromVal = 0;

// Raw image toggle (0 = dim, 1 = full brightness)
let rawFade = 0;
let rawFadeTarget = 0;
let rawFadeStart = null;
let rawFadeFromVal = 0;

// HUD
let showHud = false;
let fps = 0;
let frameCount = 0;
let fpsTime = performance.now();

// ============================================================
// UTILITIES
// ============================================================
function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = src;
  });
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);

function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

// ============================================================
// AUDIO CUE
// ============================================================
function playReadyTone() {
  try {
    const actx = new AudioContext();
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    osc.connect(gain);
    gain.connect(actx.destination);
    osc.frequency.value = 880;
    gain.gain.setValueAtTime(0.15, actx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + 0.4);
    osc.start();
    osc.stop(actx.currentTime + 0.4);
  } catch (e) {}
}

// ============================================================
// CONFIG LOADING
// ============================================================
async function loadMasterConfig() {
  const resp = await fetch('config.json?v=' + Date.now());
  if (!resp.ok) throw new Error('config.json not found');
  masterConfig = await resp.json();
}

function mergeConfig(movIdx) {
  const mvmt = masterConfig.movements[movIdx];
  config = { ...masterConfig.config, ...(mvmt.config || {}) };
}

// ============================================================
// SCENE ASSET LOADING
// ============================================================
async function loadSceneAssets(sceneData, label) {
  loadingEl.textContent = `Loading ${label}...`;
  await new Promise(r => setTimeout(r, 0));

  const cb = '?v=' + Date.now();

  const [bg, idMap, meta] = await Promise.all([
    loadImage(sceneData.image + cb),
    loadImage(sceneData.regionIdMap + cb),
    fetch(sceneData.regionMeta + cb).then(r => r.json())
  ]);

  // Use this scene's image dimensions throughout — don't rely on global IMG_W/H
  const imgW = bg.naturalWidth, imgH = bg.naturalHeight;

  const mapW = idMap.naturalWidth;
  const mapH = idMap.naturalHeight;
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = mapW;
  tmpCanvas.height = mapH;
  const tmpCtx = tmpCanvas.getContext('2d', { willReadFrequently: true });
  tmpCtx.drawImage(idMap, 0, 0);
  const mapData = tmpCtx.getImageData(0, 0, mapW, mapH).data;

  // Scale metadata to logical coordinates
  const sx = imgW / mapW, sy = imgH / mapH;
  const scaledMeta = {};
  for (const [k, v] of Object.entries(meta)) {
    scaledMeta[k] = {
      ...v,
      cx: Math.round(v.cx * sx),
      cy: Math.round(v.cy * sy),
      bbox: [
        Math.round(v.bbox[0] * sx),
        Math.round(v.bbox[1] * sy),
        Math.round(v.bbox[2] * sx),
        Math.round(v.bbox[3] * sy)
      ]
    };
  }

  // Build region runs for all regions used in groups
  const sceneGroups = sceneData.groups || {};
  const usedRegions = new Set();
  for (const g of Object.values(sceneGroups)) {
    for (const rid of g.regions) usedRegions.add(rid);
  }

  const stepX = imgW / mapW;
  const stepY = imgH / mapH;
  const runs = {};
  for (const regionId of usedRegions) {
    const m = scaledMeta[regionId];
    if (!m) continue;
    const runList = [];
    const bb = m.bbox;
    const my0 = Math.round(bb[1] * mapH / imgH);
    const my1 = Math.round(bb[3] * mapH / imgH);
    const mx0 = Math.round(bb[0] * mapW / imgW);
    const mx1 = Math.round(bb[2] * mapW / imgW);
    for (let my = my0; my <= my1; my++) {
      let runStart = -1;
      const rowOffset = my * mapW;
      for (let mx = mx0; mx <= mx1 + 1; mx++) {
        const offset = (rowOffset + mx) * 4;
        const r = mapData[offset];
        const g = mapData[offset + 1];
        const mk = mapData[offset + 2];
        const id = (mk >= 250) ? (r | (g << 8)) : -1;
        if (id === regionId && mx <= mx1) {
          if (runStart < 0) runStart = mx;
        } else {
          if (runStart >= 0) {
            runList.push(my * stepY, runStart * stepX, (mx - runStart) * stepX);
            runStart = -1;
          }
        }
      }
    }
    runs[regionId] = runList;
  }

  // Pre-render region images
  loadingEl.textContent = `Pre-rendering ${label}...`;
  await new Promise(r => setTimeout(r, 0));

  const tmpMask = document.createElement('canvas');
  const tmpMaskCtx = tmpMask.getContext('2d');
  const regImages = {};
  for (const regionId of usedRegions) {
    const m = scaledMeta[regionId];
    const runList = runs[regionId];
    if (!m || !runList || runList.length === 0) continue;
    const bx = m.bbox[0], by = m.bbox[1];
    const bw = m.bbox[2] - m.bbox[0] + 1;
    const bh = m.bbox[3] - m.bbox[1] + 1;
    const hbw = Math.ceil(bw * mapW / imgW);
    const hbh = Math.ceil(bh * mapH / imgH);
    tmpMask.width = hbw;
    tmpMask.height = hbh;
    const scaleToHX = mapW / imgW;
    const scaleToHY = mapH / imgH;
    tmpMaskCtx.clearRect(0, 0, hbw, hbh);
    tmpMaskCtx.globalCompositeOperation = 'source-over';
    tmpMaskCtx.globalAlpha = 1;
    tmpMaskCtx.fillStyle = '#fff';
    for (let i = 0; i < runList.length; i += 3) {
      tmpMaskCtx.fillRect(
        (runList[i + 1] - bx) * scaleToHX,
        (runList[i] - by) * scaleToHY,
        runList[i + 2] * scaleToHX,
        1
      );
    }
    tmpMaskCtx.globalCompositeOperation = 'source-in';
    tmpMaskCtx.drawImage(bg, bx, by, bw, bh, 0, 0, hbw, hbh);
    tmpMaskCtx.globalCompositeOperation = 'source-over';
    const regionCanvas = document.createElement('canvas');
    regionCanvas.width = hbw;
    regionCanvas.height = hbh;
    regionCanvas.getContext('2d').drawImage(tmpMask, 0, 0);
    regImages[regionId] = { canvas: regionCanvas, x: bx, y: by, w: bw, h: bh };
  }

  return {
    bgImage: bg,
    imgW,
    imgH,
    idMapData: mapData,
    idMapW: mapW,
    idMapH: mapH,
    regionMeta: scaledMeta,
    regionRuns: runs,
    regionImages: regImages,
    groups: sceneGroups,
    sequences: sceneData.sequences || {}
  };
}

// ============================================================
// MOVEMENT LOADING
// ============================================================
async function loadMovement(idx) {
  if (isLoading) return;
  isLoading = true;
  awaitingEnter = false;

  // Stop all sparkle timers and clear sequence state
  for (const state of Object.values(seqStates)) stopSparkle(state);
  seqStates = {};

  // Fade to black if currently visible
  if (sceneFade > 0.01) {
    fadeSceneOut();
    await new Promise(r => {
      const check = setInterval(() => {
        if (sceneFade < 0.01) { clearInterval(check); r(); }
      }, 50);
    });
  }

  mergeConfig(idx);

  const movement = masterConfig.movements[idx];
  const sceneList = movement.scenes || [];

  loadedScenes = [];
  for (let i = 0; i < sceneList.length; i++) {
    const sd = await loadSceneAssets(
      sceneList[i],
      `${movement.name} — scene ${i + 1}/${sceneList.length}`
    );
    loadedScenes.push(sd);
  }

  movementIdx = idx;
  xfadeActive = false;
  xfadeFromBg = null;

  if (loadedScenes.length > 0) {
    activateScene(0);
    isLoading = false;
    loadingEl.textContent = 'Press Enter to begin';
    loadingEl.style.display = 'block';
    playReadyTone();
    awaitingEnter = true;
  } else {
    isLoading = false;
    loadingEl.textContent = `${movement.name} has no scenes.`;
    loadingEl.style.display = 'block';
  }
}

function activateScene(idx) {
  if (idx < 0 || idx >= loadedScenes.length) return;
  sceneIdx = idx;
  const sd = loadedScenes[idx];

  // Stop active sparkle timers
  for (const state of Object.values(seqStates)) stopSparkle(state);

  bgImage = sd.bgImage;
  IMG_W = sd.imgW;
  IMG_H = sd.imgH;
  idMapData = sd.idMapData;
  idMapW = sd.idMapW;
  idMapH = sd.idMapH;
  regionMeta = sd.regionMeta;
  regionRuns = sd.regionRuns;
  groups = sd.groups;
  sequences = sd.sequences;

  // Reset view to full image (16:9 crop)
  let w = IMG_W;
  let h = w / ASPECT;
  if (h > IMG_H) { h = IMG_H; w = h * ASPECT; }
  view = { x: (IMG_W - w) / 2, y: (IMG_H - h) / 2, w, h };

  // Build sequence key states
  seqStates = {};
  for (const [sid, seq] of Object.entries(sequences)) {
    if (!seq.key || !seq.steps || seq.steps.length === 0) continue;
    const key = seq.key.toLowerCase();
    seqStates[key] = {
      seqId: sid,
      stepIndex: -1,
      active: false,
      opacity: 0,
      fadeStartTime: null,
      fadeDirection: null,
      fadeFromOpacity: 0,
      sparkleState: {},
      sparkleTimers: {}
    };
  }
}

function startSceneCrossfade(newIdx) {
  if (newIdx < 0 || newIdx >= loadedScenes.length) return;
  if (newIdx === sceneIdx || xfadeActive) return;

  // Stop active sequences
  for (const state of Object.values(seqStates)) stopSparkle(state);
  seqStates = {};

  xfadeFromBg = bgImage;
  xfadeFromImgW = IMG_W;
  xfadeFromImgH = IMG_H;
  xfadeActive = true;
  xfadeAlpha = 0;
  xfadeStart = performance.now();

  // Switch to new scene data (sequences start fresh, hidden until xfadeAlpha > 0)
  activateScene(newIdx);
}

// ============================================================
// RENDERING
// ============================================================
function getCanvasTransform() {
  const canvasAspect = canvas.width / canvas.height;
  const viewAspect = view.w / view.h;
  let scale, offsetX = 0, offsetY = 0;
  if (canvasAspect > viewAspect) {
    scale = canvas.height / view.h;
    offsetX = (canvas.width - view.w * scale) / 2;
  } else {
    scale = canvas.width / view.w;
    offsetY = (canvas.height - view.h * scale) / 2;
  }
  return { scale, offsetX, offsetY };
}

function brightenRegions(regionSet, litAlpha) {
  const stepY = IMG_H / idMapH;
  ctx.save();
  ctx.beginPath();
  regionSet.forEach(regionId => {
    const runs = regionRuns[regionId];
    if (!runs) return;
    for (let i = 0; i < runs.length; i += 3) {
      ctx.rect(runs[i + 1], runs[i], runs[i + 2], stepY);
    }
  });
  ctx.clip();
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, IMG_W, IMG_H);
  ctx.globalAlpha = litAlpha;
  const sat = config.litSaturate || 1;
  const con = config.litContrast || 1;
  if (sat !== 1 || con !== 1) {
    ctx.filter = `saturate(${sat}) contrast(${con})`;
  }
  ctx.drawImage(bgImage, 0, 0, IMG_W, IMG_H);
  ctx.filter = 'none';
  ctx.restore();
}

// ============================================================
// SEQUENCE STATE MACHINE
// ============================================================
function activateSequence(key) {
  const state = seqStates[key];
  if (!state || state.active) return;
  const seq = sequences[state.seqId];
  if (!seq || seq.steps.length === 0) return;
  state.stepIndex = (state.stepIndex + 1) % seq.steps.length;
  state.active = true;
  state.fadeFromOpacity = state.opacity;
  state.fadeStartTime = performance.now();
  state.fadeDirection = 'in';
  const step = seq.steps[state.stepIndex];
  if (step.effect === 'sparkle') startSparkle(state, step);
}

function deactivateSequence(key) {
  const state = seqStates[key];
  if (!state || !state.active) return;
  state.active = false;
  state.fadeFromOpacity = state.opacity;
  state.fadeStartTime = performance.now();
  state.fadeDirection = 'out';
}

function updateSequenceOpacity(state, now) {
  if (state.fadeDirection === null) return;
  const seq = sequences[state.seqId];
  const step = seq.steps[state.stepIndex];
  const duration = state.fadeDirection === 'in'
    ? (step.fadeIn || config.defaultFadeIn)
    : (step.fadeOut || config.defaultFadeOut);
  const elapsed = now - state.fadeStartTime;
  const t = Math.min(1, elapsed / duration);
  const e = easeInOutCubic(t);
  if (state.fadeDirection === 'in') {
    state.opacity = state.fadeFromOpacity + (1 - state.fadeFromOpacity) * e;
  } else {
    state.opacity = state.fadeFromOpacity * (1 - e);
  }
  if (t >= 1) {
    state.fadeDirection = null;
    if (state.opacity < 0.01) {
      state.opacity = 0;
      stopSparkle(state);
    }
  }
}

// ============================================================
// SPARKLE ENGINE — each region has its own random on/off timing
// ============================================================
function randBetween(min, max) {
  return min + Math.random() * (max - min);
}

function startSparkle(state, step) {
  stopSparkle(state);
  const group = groups[step.groupId];
  if (!group) return;
  state.sparkleState = {};
  state.sparkleTimers = {};
  group.regions.forEach(r => {
    const startOn = Math.random() > 0.5;
    state.sparkleState[r] = startOn;
    scheduleToggle(state, r, startOn);
  });
}

function scheduleToggle(state, regionId, currentlyOn) {
  const delay = currentlyOn
    ? randBetween(config.sparkleMinOn, config.sparkleMaxOn)
    : randBetween(config.sparkleMinOff, config.sparkleMaxOff);
  state.sparkleTimers[regionId] = setTimeout(() => {
    if (!state.sparkleTimers[regionId]) return;
    state.sparkleState[regionId] = !currentlyOn;
    scheduleToggle(state, regionId, !currentlyOn);
  }, delay);
}

function stopSparkle(state) {
  if (state.sparkleTimers) {
    for (const timer of Object.values(state.sparkleTimers)) clearTimeout(timer);
    state.sparkleTimers = {};
  }
  state.sparkleState = {};
}

// ============================================================
// SCENE FADE
// ============================================================
function fadeSceneOut() {
  sceneFadeTarget = 0;
  sceneFadeFromVal = sceneFade;
  sceneFadeStart = performance.now();
}

function fadeSceneIn() {
  sceneFadeTarget = 1;
  sceneFadeFromVal = sceneFade;
  sceneFadeStart = performance.now();
  awaitingEnter = false;
  loadingEl.style.display = 'none';
}

function updateSceneFade(now) {
  if (sceneFadeStart === null) return;
  const elapsed = now - sceneFadeStart;
  const t = Math.min(1, elapsed / config.sceneFadeDuration);
  const e = easeInOutCubic(t);
  sceneFade = sceneFadeFromVal + (sceneFadeTarget - sceneFadeFromVal) * e;
  if (t >= 1) {
    sceneFade = sceneFadeTarget;
    sceneFadeStart = null;
  }
}

function fadeRawIn() {
  rawFadeTarget = 1;
  rawFadeFromVal = rawFade;
  rawFadeStart = performance.now();
}

function fadeRawOut() {
  rawFadeTarget = 0;
  rawFadeFromVal = rawFade;
  rawFadeStart = performance.now();
}

function updateRawFade(now) {
  if (rawFadeStart === null) return;
  const elapsed = now - rawFadeStart;
  const t = Math.min(1, elapsed / config.sceneFadeDuration);
  const e = easeInOutCubic(t);
  rawFade = rawFadeFromVal + (rawFadeTarget - rawFadeFromVal) * e;
  if (t >= 1) {
    rawFade = rawFadeTarget;
    rawFadeStart = null;
  }
}

// ============================================================
// MAIN RENDER LOOP
// ============================================================
function renderLoop(now) {
  requestAnimationFrame(renderLoop);

  frameCount++;
  if (now - fpsTime >= 1000) {
    fps = frameCount;
    frameCount = 0;
    fpsTime = now;
  }

  updateSceneFade(now);
  updateRawFade(now);

  // Update crossfade progress
  if (xfadeActive && xfadeStart !== null) {
    const elapsed = now - xfadeStart;
    const t = Math.min(1, elapsed / config.crossfadeDuration);
    xfadeAlpha = easeInOutCubic(t);
    if (t >= 1) {
      xfadeActive = false;
      xfadeFromBg = null;
      xfadeAlpha = 1;
    }
  }

  // Update sequence opacities (only when not crossfading)
  if (!xfadeActive) {
    for (const state of Object.values(seqStates)) {
      updateSequenceOpacity(state, now);
    }
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (bgImage) {
    const { scale, offsetX, offsetY } = getCanvasTransform();
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);
    ctx.translate(-view.x, -view.y);

    const bgAlpha = (config.dimLevel + (1 - config.dimLevel) * rawFade) * sceneFade;

    if (xfadeActive && xfadeFromBg) {
      // Crossfade: draw from-scene fading out, to-scene fading in
      ctx.globalAlpha = (1 - xfadeAlpha) * bgAlpha;
      ctx.drawImage(xfadeFromBg, 0, 0, xfadeFromImgW, xfadeFromImgH);
      ctx.globalAlpha = xfadeAlpha * bgAlpha;
      ctx.drawImage(bgImage, 0, 0, IMG_W, IMG_H);
    } else {
      // Normal render
      ctx.globalAlpha = bgAlpha;
      ctx.drawImage(bgImage, 0, 0, IMG_W, IMG_H);

      // Brighten active sequence regions
      if (rawFade < 1) {
        for (const [key, state] of Object.entries(seqStates)) {
          if (state.opacity <= 0 || state.stepIndex < 0) continue;
          const seq = sequences[state.seqId];
          const step = seq.steps[state.stepIndex];
          const group = groups[step.groupId];
          if (!group) continue;
          const litAlpha = config.litLevel * state.opacity * sceneFade;
          if (litAlpha <= 0.01) continue;
          if (step.effect === 'sparkle' && Object.keys(state.sparkleState).length > 0) {
            const onRegions = new Set();
            for (const [rid, on] of Object.entries(state.sparkleState)) {
              if (on) onRegions.add(parseInt(rid));
            }
            brightenRegions(onRegions, litAlpha);
          } else {
            brightenRegions(new Set(group.regions), litAlpha);
          }
        }
      }
    }

    ctx.restore();

    // Letterbox bars
    ctx.fillStyle = '#000';
    if (offsetX > 0) {
      ctx.fillRect(0, 0, offsetX, canvas.height);
      ctx.fillRect(canvas.width - offsetX, 0, offsetX, canvas.height);
    }
    if (offsetY > 0) {
      ctx.fillRect(0, 0, canvas.width, offsetY);
      ctx.fillRect(0, canvas.height - offsetY, canvas.width, offsetY);
    }
  }

  // HUD
  if (showHud) {
    const mvmt = masterConfig ? masterConfig.movements[movementIdx] : null;
    const movName = mvmt ? mvmt.name : '—';
    const sceneName = mvmt ? (mvmt.scenes[sceneIdx]?.name || '—') : '—';
    const totalScenes = loadedScenes.length;

    const activeKeys = Object.entries(seqStates)
      .filter(([k, s]) => s.opacity > 0 && s.stepIndex >= 0)
      .map(([k, s]) => {
        const seq = sequences[s.seqId];
        const step = seq.steps[s.stepIndex];
        const group = groups[step.groupId];
        return `${k.toUpperCase()}:${group ? group.name : '?'}(${s.stepIndex + 1}/${seq.steps.length}) ${step.effect} ${Math.round(s.opacity * 100)}%`;
      });

    hud.style.display = 'block';
    hud.innerHTML = [
      `FPS: ${fps} | ${movName} &gt; ${sceneName} (${sceneIdx + 1}/${totalScenes})`,
      `Dim: ${config.dimLevel} Lit: ${config.litLevel} Sat: ${config.litSaturate} Con: ${config.litContrast}`,
      `FadeIn: ${config.defaultFadeIn}ms FadeOut: ${config.defaultFadeOut}ms`,
      `SceneFade: ${Math.round(sceneFade * 100)}% Raw: ${Math.round(rawFade * 100)}%`,
      xfadeActive ? `Crossfade: ${Math.round(xfadeAlpha * 100)}%` : '',
      ...activeKeys
    ].filter(Boolean).join('<br>');
  } else {
    hud.style.display = 'none';
  }
}

// ============================================================
// KEYBOARD
// ============================================================
document.addEventListener('keydown', (e) => {
  if (e.repeat) return;

  const key = e.key;
  const keyL = key.toLowerCase();

  // HUD toggle
  if (keyL === 'h') {
    showHud = !showHud;
    return;
  }

  // Reload config
  if (keyL === 'r') {
    loadMasterConfig().then(() => {
      if (movementIdx >= 0) mergeConfig(movementIdx);
      console.log('Config reloaded');
    });
    return;
  }

  // Movement switching: 1, 2, 3
  if (key === '1' || key === '2' || key === '3') {
    const idx = parseInt(key) - 1;
    if (!masterConfig || idx >= masterConfig.movements.length) return;
    if (idx === movementIdx && !isLoading) return;
    loadMovement(idx);
    return;
  }

  // Enter = fade in from black
  if (key === 'Enter') {
    if (loadedScenes.length > 0) fadeSceneIn();
    return;
  }

  // Escape = fade to black
  if (key === 'Escape') {
    fadeRawOut();
    fadeSceneOut();
    return;
  }

  // Space = toggle raw image
  if (key === ' ') {
    if (rawFadeTarget === 0) fadeRawIn(); else fadeRawOut();
    return;
  }

  // Left/Right arrow = crossfade between scenes (no wrap)
  if (key === 'ArrowRight') {
    if (!isLoading && !xfadeActive && sceneIdx < loadedScenes.length - 1) {
      startSceneCrossfade(sceneIdx + 1);
    }
    return;
  }
  if (key === 'ArrowLeft') {
    if (!isLoading && !xfadeActive && sceneIdx > 0) {
      startSceneCrossfade(sceneIdx - 1);
    }
    return;
  }

  // Fullscreen
  if (keyL === 'f') {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().then(resize);
    } else {
      document.exitFullscreen().then(resize);
    }
    return;
  }

  // Sequence activation
  if (seqStates[keyL]) {
    activateSequence(keyL);
    return;
  }
});

document.addEventListener('keyup', (e) => {
  const keyL = e.key.toLowerCase();
  if (seqStates[keyL]) {
    deactivateSequence(keyL);
  }
});

document.addEventListener('contextmenu', e => e.preventDefault());

// ============================================================
// START
// ============================================================
async function init() {
  resize();
  loadingEl.textContent = 'Loading config...';

  try {
    await loadMasterConfig();
  } catch (e) {
    loadingEl.textContent = 'Error: config.json not found.\nCreate it or start server.py first.';
    return;
  }

  requestAnimationFrame(renderLoop);
  await loadMovement(0);
}

init();
</script>
</body>
</html>

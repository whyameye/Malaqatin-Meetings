<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Ceiling Performance</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: #000; overflow: hidden; cursor: none; }
  canvas { display: block; }
  #loading {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    color: white; font: 24px monospace; z-index: 20;
    text-align: center; line-height: 1.6;
  }
  #hud {
    position: fixed; top: 10px; left: 10px;
    color: #0f0; font: 12px monospace;
    background: rgba(0,0,0,0.7); padding: 8px 12px;
    border-radius: 4px; pointer-events: none; z-index: 10;
    display: none;
  }
</style>
</head>
<body>
<div id="loading">Loading...</div>
<canvas id="canvas"></canvas>
<div id="hud"></div>

<script>
// ============================================================
// CONSTANTS + URL PARAMS
// ============================================================
let IMG_W = 2731, IMG_H = 2048; // updated per scene from bgImage dimensions
const ASPECT = 16 / 9;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const hud = document.getElementById('hud');
const loadingEl = document.getElementById('loading');

const urlParams = new URLSearchParams(window.location.search);
const ROLE = urlParams.get('role') || 'performer'; // 'performer' | 'display'
const WS_URL = urlParams.get('ws') || null;        // e.g. ws://192.168.x.x:8765
const IS_PERFORMER = ROLE === 'performer';

// ============================================================
// CONFIG (merged from config.json global + movement override)
// ============================================================
let masterConfig = null;
let config = {
  dimLevel: 0.15,
  litLevel: 1.00,
  fadeIn: 200,
  fadeOut: 500,
  sparkleSpeed: 100,
  sparkleMinOn: 20,
  sparkleMaxOn: 80,
  sparkleMinOff: 20,
  sparkleMaxOff: 80,
  litBrightness: 1,
  litSaturate: 1.8,
  litContrast: 1.3,
  sceneFadeDuration: 1000,
  crossfadeDuration: 1500
};

// ============================================================
// STATE
// ============================================================
// Movement / scene navigation
let movementIdx = -1;       // currently loaded movement (0-indexed)
let sceneIdx = 0;           // current scene within movement
let loadedScenes = [];      // array of scene data objects
let isLoading = false;
let awaitingEnter = false;       // after loading, waiting for Enter to fade in
let awaitingKnobReset = false;   // waiting for all knobs to confirm positions
let knobsToConfirm = new Set();  // CCs that must be confirmed
let knobsConfirmed = new Set();  // CCs that have confirmed
let initialKnobCheckDone = false; // knob check only happens once at startup

// Current scene's render data (set from loadedScenes[sceneIdx])
let bgImage = null;
let idMapData = null;
let idMapW = IMG_W, idMapH = IMG_H;
let regionMeta = null;
let regionRuns = {};
let groups = {};
let sequences = {};

// View (16:9 crop of the image)
let view = { x: 0, y: 0, w: IMG_W, h: IMG_W / ASPECT };

// Sequence key states: keyChar -> seqState
let seqStates = {};

// Crossfade between scenes
let xfadeActive = false;
let xfadeFromBg = null;     // bgImage of the "from" scene
let xfadeFromImgW = 2731, xfadeFromImgH = 2048; // dimensions of the from-scene image
let xfadeFromView = null;   // view of the "from" scene
let xfadeAlpha = 0;         // 0 = from scene, 1 = to scene
let xfadeStart = null;
let pendingCrossfadeIdx = -1; // waiting for sequences to fade out before starting

// Global scene fade (0 = black, 1 = visible)
let sceneFade = 0;
let sceneFadeTarget = 0;
let sceneFadeStart = null;
let sceneFadeFromVal = 0;

// Raw image toggle (0 = dim, 1 = full brightness)
let rawFade = 0;
let rawFadeTarget = 0;
let rawFadeStart = null;
let rawFadeFromVal = 0;

// HUD
let showHud = IS_PERFORMER; // shown by default on performer, never on display
let fps = 0;
let frameCount = 0;
let fpsTime = performance.now();

// Keys physically held down (keyboard or MIDI) — persists across scene changes
let physicallyHeldKeys = new Set();

// WebSocket
let ws = null;
let wsStatus = WS_URL ? 'connecting' : 'off'; // 'off' | 'connecting' | 'connected' | 'disconnected'

// MIDI
let midiStatus = 'unavailable'; // 'unavailable' | 'searching' | 'connected' | 'not found'
let midiDeviceName = null;
let midiNoteMap = {}; // note number → keyboard key char (built from config.midiNoteMap)
let knobValues = {}; // CC number → last value (for knob movement detection)

// ============================================================
// UTILITIES
// ============================================================
function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = src;
  });
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);

function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

// ============================================================
// AUDIO CUE
// ============================================================
function playReadyTone() {
  try {
    const actx = new AudioContext();
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    osc.connect(gain);
    gain.connect(actx.destination);
    osc.frequency.value = 880;
    gain.gain.setValueAtTime(0.15, actx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + 0.4);
    osc.start();
    osc.stop(actx.currentTime + 0.4);
  } catch (e) {}
}

// ============================================================
// CONFIG LOADING
// ============================================================
async function loadMasterConfig() {
  const resp = await fetch('config.json?v=' + Date.now());
  if (!resp.ok) throw new Error('config.json not found');
  masterConfig = await resp.json();
}

function mergeConfig(movIdx) {
  const mvmt = masterConfig.movements[movIdx];
  config = { ...masterConfig.config, ...(mvmt.config || {}) };
}

// ============================================================
// SCENE ASSET LOADING
// ============================================================
async function loadSceneAssets(sceneData, label) {
  if (!initialKnobCheckDone) {
    loadingEl.textContent = `Loading ${label}...`;
    loadingEl.style.display = 'block';
  }
  await new Promise(r => setTimeout(r, 0));

  const cb = '?v=' + Date.now();

  const [bg, idMap, meta] = await Promise.all([
    loadImage(sceneData.image + cb),
    loadImage(sceneData.regionIdMap + cb),
    fetch(sceneData.regionMeta + cb).then(r => r.json())
  ]);

  // Use this scene's image dimensions throughout — don't rely on global IMG_W/H
  const imgW = bg.naturalWidth, imgH = bg.naturalHeight;

  const mapW = idMap.naturalWidth;
  const mapH = idMap.naturalHeight;
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = mapW;
  tmpCanvas.height = mapH;
  const tmpCtx = tmpCanvas.getContext('2d', { willReadFrequently: true });
  tmpCtx.drawImage(idMap, 0, 0);
  const mapData = tmpCtx.getImageData(0, 0, mapW, mapH).data;

  // Scale metadata to logical coordinates
  const sx = imgW / mapW, sy = imgH / mapH;
  const scaledMeta = {};
  for (const [k, v] of Object.entries(meta)) {
    scaledMeta[k] = {
      ...v,
      cx: Math.round(v.cx * sx),
      cy: Math.round(v.cy * sy),
      bbox: [
        Math.round(v.bbox[0] * sx),
        Math.round(v.bbox[1] * sy),
        Math.round(v.bbox[2] * sx),
        Math.round(v.bbox[3] * sy)
      ]
    };
  }

  // Build region runs for all regions used in groups
  const sceneGroups = sceneData.groups || {};
  const usedRegions = new Set();
  for (const g of Object.values(sceneGroups)) {
    for (const rid of g.regions) usedRegions.add(rid);
  }

  const stepX = imgW / mapW;
  const stepY = imgH / mapH;
  const runs = {};
  for (const regionId of usedRegions) {
    const m = scaledMeta[regionId];
    if (!m) continue;
    const runList = [];
    const bb = m.bbox;
    const my0 = Math.round(bb[1] * mapH / imgH);
    const my1 = Math.round(bb[3] * mapH / imgH);
    const mx0 = Math.round(bb[0] * mapW / imgW);
    const mx1 = Math.round(bb[2] * mapW / imgW);
    for (let my = my0; my <= my1; my++) {
      let runStart = -1;
      const rowOffset = my * mapW;
      for (let mx = mx0; mx <= mx1 + 1; mx++) {
        const offset = (rowOffset + mx) * 4;
        const r = mapData[offset];
        const g = mapData[offset + 1];
        const mk = mapData[offset + 2];
        const id = (mk >= 250) ? (r | (g << 8)) : -1;
        if (id === regionId && mx <= mx1) {
          if (runStart < 0) runStart = mx;
        } else {
          if (runStart >= 0) {
            runList.push(my * stepY, runStart * stepX, (mx - runStart) * stepX);
            runStart = -1;
          }
        }
      }
    }
    runs[regionId] = runList;
  }

  // Pre-render region images
  if (!initialKnobCheckDone) loadingEl.textContent = `Pre-rendering ${label}...`;
  await new Promise(r => setTimeout(r, 0));

  const tmpMask = document.createElement('canvas');
  const tmpMaskCtx = tmpMask.getContext('2d');
  const regImages = {};
  for (const regionId of usedRegions) {
    const m = scaledMeta[regionId];
    const runList = runs[regionId];
    if (!m || !runList || runList.length === 0) continue;
    const bx = m.bbox[0], by = m.bbox[1];
    const bw = m.bbox[2] - m.bbox[0] + 1;
    const bh = m.bbox[3] - m.bbox[1] + 1;
    const hbw = Math.ceil(bw * mapW / imgW);
    const hbh = Math.ceil(bh * mapH / imgH);
    tmpMask.width = hbw;
    tmpMask.height = hbh;
    const scaleToHX = mapW / imgW;
    const scaleToHY = mapH / imgH;
    tmpMaskCtx.clearRect(0, 0, hbw, hbh);
    tmpMaskCtx.globalCompositeOperation = 'source-over';
    tmpMaskCtx.globalAlpha = 1;
    tmpMaskCtx.fillStyle = '#fff';
    for (let i = 0; i < runList.length; i += 3) {
      tmpMaskCtx.fillRect(
        (runList[i + 1] - bx) * scaleToHX,
        (runList[i] - by) * scaleToHY,
        runList[i + 2] * scaleToHX,
        1
      );
    }
    tmpMaskCtx.globalCompositeOperation = 'source-in';
    tmpMaskCtx.drawImage(bg, bx, by, bw, bh, 0, 0, hbw, hbh);
    tmpMaskCtx.globalCompositeOperation = 'source-over';
    const regionCanvas = document.createElement('canvas');
    regionCanvas.width = hbw;
    regionCanvas.height = hbh;
    regionCanvas.getContext('2d').drawImage(tmpMask, 0, 0);
    regImages[regionId] = { canvas: regionCanvas, x: bx, y: by, w: bw, h: bh };
  }

  return {
    bgImage: bg,
    imgW,
    imgH,
    idMapData: mapData,
    idMapW: mapW,
    idMapH: mapH,
    regionMeta: scaledMeta,
    regionRuns: runs,
    regionImages: regImages,
    groups: sceneGroups,
    sequences: sceneData.sequences || {}
  };
}

// ============================================================
// MOVEMENT LOADING
// ============================================================
async function loadMovement(idx) {
  if (isLoading) return;
  isLoading = true;
  awaitingEnter = false;

  // Stop all sparkle timers and clear sequence state
  for (const state of Object.values(seqStates)) stopSparkle(state);
  seqStates = {};

  // Save current scene for crossfade after loading
  const prevBgImage = bgImage;
  const prevImgW = IMG_W;
  const prevImgH = IMG_H;
  const prevView = { ...view };

  mergeConfig(idx);

  const movement = masterConfig.movements[idx];
  const sceneList = movement.scenes || [];

  loadedScenes = [];
  for (let i = 0; i < sceneList.length; i++) {
    const sd = await loadSceneAssets(
      sceneList[i],
      `${movement.name} — scene ${i + 1}/${sceneList.length}`
    );
    loadedScenes.push(sd);
  }

  movementIdx = idx;
  pendingCrossfadeIdx = -1;

  if (loadedScenes.length > 0) {
    // Crossfade from previous scene if one was showing
    if (prevBgImage) {
      xfadeFromBg = prevBgImage;
      xfadeFromImgW = prevImgW;
      xfadeFromImgH = prevImgH;
      xfadeFromView = prevView;
      xfadeActive = true;
      xfadeAlpha = 0;
      xfadeStart = performance.now();
    } else {
      xfadeActive = false;
      xfadeFromBg = null;
    }
    activateScene(0);
    isLoading = false;
    loadingEl.style.display = 'block';
    if (midiStatus === 'connected' && !initialKnobCheckDone) {
      // Build set of CCs to confirm — all configured knobs + fade knob
      knobsToConfirm = new Set([...getKnobCCs(), getFadeKnobCC()].filter(cc => cc != null));
      knobsConfirmed = new Set();
      if (knobsToConfirm.size > 0) {
        awaitingKnobReset = true;
        updateKnobResetPrompt();
      } else {
        initialKnobCheckDone = true;
        loadingEl.textContent = 'Press Enter or any piano key to begin';
        playReadyTone();
        awaitingEnter = true;
      }
    } else if (!initialKnobCheckDone) {
      loadingEl.textContent = 'Press Enter to begin';
      playReadyTone();
      awaitingEnter = true;
    } else {
      // Subsequent movement loads — knob 8 controls fade in/out
      loadingEl.style.display = 'none';
    }
  } else {
    isLoading = false;
    loadingEl.textContent = `${movement.name} has no scenes.`;
    loadingEl.style.display = 'block';
  }
}

function activateScene(idx) {
  if (idx < 0 || idx >= loadedScenes.length) return;
  sceneIdx = idx;
  const sd = loadedScenes[idx];

  // Stop active sparkle timers
  for (const state of Object.values(seqStates)) stopSparkle(state);

  bgImage = sd.bgImage;
  IMG_W = sd.imgW;
  IMG_H = sd.imgH;
  idMapData = sd.idMapData;
  idMapW = sd.idMapW;
  idMapH = sd.idMapH;
  regionMeta = sd.regionMeta;
  regionRuns = sd.regionRuns;
  groups = sd.groups;
  sequences = sd.sequences;

  // Reset view to full image
  view = { x: 0, y: 0, w: IMG_W, h: IMG_H };

  // Build sequence key states
  seqStates = {};
  for (const [sid, seq] of Object.entries(sequences)) {
    if (!seq.key || !seq.steps || seq.steps.length === 0) continue;
    const key = seq.key.toLowerCase();
    seqStates[key] = {
      seqId: sid,
      stepIndex: -1,
      active: false,
      opacity: 0,
      fadeStartTime: null,
      fadeDirection: null,
      fadeFromOpacity: 0,
      sparkleState: {},
      sparkleTimers: {}
    };
  }
}

function startSceneCrossfade(newIdx) {
  if (newIdx < 0 || newIdx >= loadedScenes.length) return;
  if (newIdx === sceneIdx || xfadeActive) return;

  // Force-deactivate any active sequences so they fade out first
  for (const state of Object.values(seqStates)) {
    if (state.active) {
      state.active = false;
      state.fadeFromOpacity = state.opacity;
      state.fadeStartTime = performance.now();
      state.fadeDirection = 'out';
    }
  }
  pendingCrossfadeIdx = newIdx;
}

function _beginCrossfade(newIdx) {
  for (const state of Object.values(seqStates)) stopSparkle(state);
  seqStates = {};

  xfadeFromBg = bgImage;
  xfadeFromImgW = IMG_W;
  xfadeFromImgH = IMG_H;
  xfadeFromView = { ...view };
  xfadeActive = true;
  xfadeAlpha = 0;
  xfadeStart = performance.now();

  activateScene(newIdx);

  // Re-activate any physically held keys in the new scene
  for (const key of physicallyHeldKeys) {
    if (seqStates[key]) activateSequence(key);
  }
}

// ============================================================
// RENDERING
// ============================================================
function getCanvasTransform(v) {
  const canvasAspect = canvas.width / canvas.height;
  const viewAspect = v.w / v.h;
  let scale, offsetX = 0, offsetY = 0;
  if (canvasAspect > viewAspect) {
    scale = canvas.height / v.h;
    offsetX = (canvas.width - v.w * scale) / 2;
  } else {
    scale = canvas.width / v.w;
    offsetY = (canvas.height - v.h * scale) / 2;
  }
  return { scale, offsetX, offsetY };
}

function brightenRegions(regionSet, litAlpha, bri, sat, con) {
  const stepY = IMG_H / idMapH;
  ctx.save();
  ctx.beginPath();
  regionSet.forEach(regionId => {
    const runs = regionRuns[regionId];
    if (!runs) return;
    for (let i = 0; i < runs.length; i += 3) {
      ctx.rect(runs[i + 1], runs[i], runs[i + 2], stepY);
    }
  });
  ctx.clip();
  ctx.globalAlpha = litAlpha;
  if (bri !== 1 || sat !== 1 || con !== 1) {
    ctx.filter = `brightness(${bri}) saturate(${sat}) contrast(${con})`;
  }
  ctx.drawImage(bgImage, 0, 0, IMG_W, IMG_H);
  ctx.filter = 'none';
  ctx.restore();
}

// ============================================================
// SEQUENCE STATE MACHINE
// ============================================================
function activateSequence(key) {
  const state = seqStates[key];
  if (!state || state.active) return;
  const seq = sequences[state.seqId];
  if (!seq || seq.steps.length === 0) return;
  state.stepIndex = (state.stepIndex + 1) % seq.steps.length;
  state.active = true;
  state.fadeFromOpacity = state.opacity;
  state.fadeStartTime = performance.now();
  state.fadeDirection = 'in';
  const step = seq.steps[state.stepIndex];
  if (step.effect === 'sparkle') startSparkle(state, step);
}

function deactivateSequence(key) {
  const state = seqStates[key];
  if (!state || !state.active) return;
  state.active = false;
  state.fadeFromOpacity = state.opacity;
  state.fadeStartTime = performance.now();
  state.fadeDirection = 'out';
}

function updateSequenceOpacity(state, now) {
  if (state.fadeDirection === null) return;
  const seq = sequences[state.seqId];
  const step = seq.steps[state.stepIndex];
  const duration = state.fadeDirection === 'in'
    ? (seq.fadeIn ?? config.fadeIn)
    : (seq.fadeOut ?? config.fadeOut);
  const elapsed = now - state.fadeStartTime;
  const t = Math.min(1, elapsed / duration);
  const e = easeInOutCubic(t);
  if (state.fadeDirection === 'in') {
    state.opacity = state.fadeFromOpacity + (1 - state.fadeFromOpacity) * e;
  } else {
    state.opacity = state.fadeFromOpacity * (1 - e);
  }
  if (t >= 1) {
    state.fadeDirection = null;
    if (state.opacity < 0.01) {
      state.opacity = 0;
      stopSparkle(state);
    }
  }
}

// ============================================================
// SPARKLE ENGINE — each region has its own random on/off timing
// ============================================================
function randBetween(min, max) {
  return min + Math.random() * (max - min);
}

function startSparkle(state, step) {
  stopSparkle(state);
  const group = groups[step.groupId];
  if (!group) return;
  state.sparkleState = {};
  state.sparkleTimers = {};
  group.regions.forEach(r => {
    const startOn = Math.random() > 0.5;
    state.sparkleState[r] = startOn;
    scheduleToggle(state, r, startOn);
  });
}

function scheduleToggle(state, regionId, currentlyOn) {
  const delay = currentlyOn
    ? randBetween(config.sparkleMinOn, config.sparkleMaxOn)
    : randBetween(config.sparkleMinOff, config.sparkleMaxOff);
  state.sparkleTimers[regionId] = setTimeout(() => {
    if (!state.sparkleTimers[regionId]) return;
    state.sparkleState[regionId] = !currentlyOn;
    scheduleToggle(state, regionId, !currentlyOn);
  }, delay);
}

function stopSparkle(state) {
  if (state.sparkleTimers) {
    for (const timer of Object.values(state.sparkleTimers)) clearTimeout(timer);
    state.sparkleTimers = {};
  }
  state.sparkleState = {};
}

// ============================================================
// SCENE FADE
// ============================================================
function fadeSceneOut() {
  sceneFadeTarget = 0;
  sceneFadeFromVal = sceneFade;
  sceneFadeStart = performance.now();
}

function fadeSceneIn() {
  sceneFadeTarget = 1;
  sceneFadeFromVal = sceneFade;
  sceneFadeStart = performance.now();
  awaitingEnter = false;
  loadingEl.style.display = 'none';
}

function updateSceneFade(now) {
  if (sceneFadeStart === null) return;
  const elapsed = now - sceneFadeStart;
  const t = Math.min(1, elapsed / config.sceneFadeDuration);
  const e = easeInOutCubic(t);
  sceneFade = sceneFadeFromVal + (sceneFadeTarget - sceneFadeFromVal) * e;
  if (t >= 1) {
    sceneFade = sceneFadeTarget;
    sceneFadeStart = null;
  }
}

function fadeRawIn() {
  rawFadeTarget = 1;
  rawFadeFromVal = rawFade;
  rawFadeStart = performance.now();
}

function fadeRawOut() {
  rawFadeTarget = 0;
  rawFadeFromVal = rawFade;
  rawFadeStart = performance.now();
}

function updateRawFade(now) {
  if (rawFadeStart === null) return;
  const elapsed = now - rawFadeStart;
  const t = Math.min(1, elapsed / config.sceneFadeDuration);
  const e = easeInOutCubic(t);
  rawFade = rawFadeFromVal + (rawFadeTarget - rawFadeFromVal) * e;
  if (t >= 1) {
    rawFade = rawFadeTarget;
    rawFadeStart = null;
  }
}

// ============================================================
// MAIN RENDER LOOP
// ============================================================
function renderLoop(now) {
  requestAnimationFrame(renderLoop);

  frameCount++;
  if (now - fpsTime >= 1000) {
    fps = frameCount;
    frameCount = 0;
    fpsTime = now;
  }

  updateSceneFade(now);
  updateRawFade(now);

  // Update crossfade progress
  if (xfadeActive && xfadeStart !== null) {
    const elapsed = now - xfadeStart;
    const t = Math.min(1, elapsed / config.crossfadeDuration);
    xfadeAlpha = easeInOutCubic(t);
    if (t >= 1) {
      xfadeActive = false;
      xfadeFromBg = null;
      xfadeAlpha = 1;
    }
  }

  // Update sequence opacities (only when not crossfading)
  if (!xfadeActive) {
    for (const state of Object.values(seqStates)) {
      updateSequenceOpacity(state, now);
    }
    // Start pending crossfade once all sequences have faded out
    if (pendingCrossfadeIdx >= 0 && Object.values(seqStates).every(s => s.opacity <= 0.01)) {
      _beginCrossfade(pendingCrossfadeIdx);
      pendingCrossfadeIdx = -1;
    }
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (bgImage) {
    // Compute effectiveDimLevel: active sequences can darken the background further
    let effectiveDimLevel = config.dimLevel;
    for (const state of Object.values(seqStates)) {
      if (state.opacity <= 0 || state.stepIndex < 0) continue;
      const seq = sequences[state.seqId];
      if (seq.dimLevel != null) {
        const d = config.dimLevel + (seq.dimLevel - config.dimLevel) * state.opacity;
        effectiveDimLevel = Math.min(effectiveDimLevel, d);
      }
    }
    const bgAlpha = (effectiveDimLevel + (1 - effectiveDimLevel) * rawFade) * sceneFade;

    if (xfadeActive && xfadeFromBg) {
      // Crossfade: each scene uses its own transform so neither changes
      // apparent size during the transition
      const ft = getCanvasTransform(xfadeFromView);
      ctx.save();
      ctx.translate(ft.offsetX, ft.offsetY);
      ctx.scale(ft.scale, ft.scale);
      ctx.translate(-xfadeFromView.x, -xfadeFromView.y);
      ctx.globalAlpha = (1 - xfadeAlpha) * bgAlpha;
      ctx.drawImage(xfadeFromBg, 0, 0, xfadeFromImgW, xfadeFromImgH);
      ctx.restore();

      const tt = getCanvasTransform(view);
      ctx.save();
      ctx.translate(tt.offsetX, tt.offsetY);
      ctx.scale(tt.scale, tt.scale);
      ctx.translate(-view.x, -view.y);
      ctx.globalAlpha = xfadeAlpha * bgAlpha;
      ctx.drawImage(bgImage, 0, 0, IMG_W, IMG_H);
      ctx.restore();
      // No explicit letterbox bars during crossfade — clearRect leaves
      // uncovered areas transparent, showing the black body background.
    } else {
      // Normal render
      const { scale, offsetX, offsetY } = getCanvasTransform(view);
      ctx.save();
      ctx.translate(offsetX, offsetY);
      ctx.scale(scale, scale);
      ctx.translate(-view.x, -view.y);

      ctx.globalAlpha = bgAlpha;
      ctx.drawImage(bgImage, 0, 0, IMG_W, IMG_H);

      // Brighten active sequence regions
      if (rawFade < 1) {
        for (const [key, state] of Object.entries(seqStates)) {
          if (state.opacity <= 0 || state.stepIndex < 0) continue;
          const seq = sequences[state.seqId];
          const step = seq.steps[state.stepIndex];
          const group = groups[step.groupId];
          if (!group) continue;
          const litAlpha = Math.min(1, (seq.litLevel ?? config.litLevel) * state.opacity * sceneFade);
          if (litAlpha <= 0.01) continue;
          const bri = seq.litBrightness ?? config.litBrightness ?? 1;
          const sat = seq.litSaturate ?? config.litSaturate ?? 1;
          const con = seq.litContrast ?? config.litContrast ?? 1;
          if (step.effect === 'sparkle' && Object.keys(state.sparkleState).length > 0) {
            const onRegions = new Set();
            for (const [rid, on] of Object.entries(state.sparkleState)) {
              if (on) onRegions.add(parseInt(rid));
            }
            brightenRegions(onRegions, litAlpha, bri, sat, con);
          } else {
            brightenRegions(new Set(group.regions), litAlpha, bri, sat, con);
          }
        }
      }

      ctx.restore();

      // Letterbox bars
      ctx.fillStyle = '#000';
      if (offsetX > 0) {
        ctx.fillRect(0, 0, offsetX, canvas.height);
        ctx.fillRect(canvas.width - offsetX, 0, offsetX, canvas.height);
      }
      if (offsetY > 0) {
        ctx.fillRect(0, 0, canvas.width, offsetY);
        ctx.fillRect(0, canvas.height - offsetY, canvas.width, offsetY);
      }
    }
  }

  // HUD (performer only)
  if (showHud && IS_PERFORMER) {
    const mvmt = masterConfig ? masterConfig.movements[movementIdx] : null;
    const movName = mvmt ? mvmt.name : '—';
    const sceneName = mvmt ? (mvmt.scenes[sceneIdx]?.name || '—') : '—';
    const totalScenes = loadedScenes.length;

    const activeKeys = Object.entries(seqStates)
      .filter(([k, s]) => s.opacity > 0 && s.stepIndex >= 0)
      .map(([k, s]) => {
        const seq = sequences[s.seqId];
        const step = seq.steps[s.stepIndex];
        const group = groups[step.groupId];
        return `${k.toUpperCase()}:${group ? group.name : '?'}(${s.stepIndex + 1}/${seq.steps.length}) ${step.effect} ${Math.round(s.opacity * 100)}%`;
      });

    const wsLabel = WS_URL
      ? `WS: ${wsStatus}`
      : 'WS: off';
    const midiLabel = `MIDI: ${midiDeviceName || midiStatus}`;

    hud.style.display = 'block';
    hud.innerHTML = [
      `FPS: ${fps} | ${wsLabel} | ${midiLabel} | Wake: ${wakeLockStatus}`,
      `${movName} &gt; ${sceneName} (${sceneIdx + 1}/${totalScenes})`,
      `Dim: ${config.dimLevel} Lit: ${config.litLevel} Sat: ${config.litSaturate} Con: ${config.litContrast}`,
      `FadeIn: ${config.fadeIn}ms FadeOut: ${config.fadeOut}ms Sparkle: ${config.sparkleSpeed}ms`,
      `SceneFade: ${Math.round(sceneFade * 100)}% Raw: ${Math.round(rawFade * 100)}%`,
      xfadeActive ? `Crossfade: ${Math.round(xfadeAlpha * 100)}%` : '',
      ...activeKeys
    ].filter(Boolean).join('<br>');
  } else {
    hud.style.display = 'none';
  }
}

// ============================================================
// WEBSOCKET
// ============================================================
function connectWebSocket() {
  if (!WS_URL) return;
  wsStatus = 'connecting';
  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    wsStatus = 'connected';
    console.log('WebSocket connected:', WS_URL);
  };

  ws.onclose = () => {
    wsStatus = 'disconnected';
    ws = null;
    console.log('WebSocket disconnected, retrying in 3s...');
    setTimeout(connectWebSocket, 3000);
  };

  ws.onerror = () => {
    wsStatus = 'disconnected';
  };

  ws.onmessage = (e) => {
    if (IS_PERFORMER) return; // display only
    try {
      const msg = JSON.parse(e.data);
      handleRemoteEvent(msg);
    } catch {}
  };
}

function sendEvent(msg) {
  if (!IS_PERFORMER || !ws || ws.readyState !== WebSocket.OPEN) return;
  ws.send(JSON.stringify(msg));
}

function handleRemoteEvent(msg) {
  switch (msg.type) {
    case 'activate':   activateSequence(msg.key); break;
    case 'deactivate': deactivateSequence(msg.key); break;
    case 'scene':
      if (!isLoading && !xfadeActive && msg.sceneIdx !== sceneIdx) {
        startSceneCrossfade(msg.sceneIdx);
      }
      break;
    case 'movement':
      if (msg.movementIdx !== movementIdx) loadMovement(msg.movementIdx);
      break;
    case 'fade':
      if (msg.action === 'in') fadeSceneIn();
      else if (msg.action === 'out') { fadeRawOut(); fadeSceneOut(); }
      break;
    case 'raw':
      if (msg.action === 'in') fadeRawIn();
      else if (msg.action === 'out') fadeRawOut();
      break;
  }
}

// ============================================================
// WAKE LOCK — prevent screensaver / display sleep
// ============================================================
let wakeLock = null;
let wakeLockStatus = 'pending'; // 'pending' | 'active' | 'released' | 'unavailable'

async function requestWakeLock() {
  if (!('wakeLock' in navigator)) {
    wakeLockStatus = 'unavailable';
    return;
  }
  try {
    wakeLock = await navigator.wakeLock.request('screen');
    wakeLockStatus = 'active';
    wakeLock.addEventListener('release', () => { wakeLock = null; wakeLockStatus = 'released'; });
  } catch (e) {
    wakeLockStatus = 'unavailable';
  }
}

// Re-acquire wake lock if released when tab becomes visible again
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && !wakeLock) requestWakeLock();
});

// ============================================================
// MIDI
// ============================================================
function initMidi() {
  if (!IS_PERFORMER) return;
  if (!navigator.requestMIDIAccess) {
    midiStatus = 'unavailable';
    return;
  }
  midiStatus = 'searching';
  navigator.requestMIDIAccess({ sysex: false }).then(midi => {
    connectMidiInputs(midi);
    midi.onstatechange = () => connectMidiInputs(midi);
  }).catch(() => {
    midiStatus = 'unavailable';
  });
}

function connectMidiInputs(midi) {
  const inputs = [...midi.inputs.values()];
  // Filter out virtual/loopback ports
  const real = inputs.filter(i => !i.name.toLowerCase().includes('through'));
  if (real.length === 0) {
    midiStatus = 'not found';
    midiDeviceName = null;
    inputs.forEach(i => { i.onmidimessage = null; });
    return;
  }
  midiStatus = 'connected';
  midiDeviceName = real[0].name;
  inputs.forEach(i => { i.onmidimessage = onMidiMessage; });
}

function buildMidiNoteMap() {
  midiNoteMap = {};
  if (!masterConfig || !masterConfig.config || !masterConfig.config.midiNoteMap) return;
  for (const [key, note] of Object.entries(masterConfig.config.midiNoteMap)) {
    midiNoteMap[note] = key.toLowerCase();
  }
}

function onMidiMessage(e) {
  const [status, data1, data2] = e.data;
  const type = status & 0xf0;

  if (type === 0x90 && data2 > 0) {
    // Note On — any key starts the performance if waiting
    if (awaitingEnter) {
      fadeSceneIn();
      sendEvent({ type: 'fade', action: 'in' });
    }
    const key = midiNoteMap[data1];
    if (key === 'scene_next') {
      if (!isLoading && !xfadeActive && sceneIdx < loadedScenes.length - 1) {
        startSceneCrossfade(sceneIdx + 1);
        sendEvent({ type: 'scene', sceneIdx: sceneIdx + 1 });
      }
    } else if (key === 'scene_prev') {
      if (!isLoading && !xfadeActive && sceneIdx > 0) {
        startSceneCrossfade(sceneIdx - 1);
        sendEvent({ type: 'scene', sceneIdx: sceneIdx - 1 });
      }
    } else if (key) {
      physicallyHeldKeys.add(key);
      activateSequence(key);
      sendEvent({ type: 'activate', key });
    }
  } else if (type === 0x80 || (type === 0x90 && data2 === 0)) {
    // Note Off
    const key = midiNoteMap[data1];
    if (key) {
      physicallyHeldKeys.delete(key);
      deactivateSequence(key);
      sendEvent({ type: 'deactivate', key });
    }
  } else if (type === 0xb0) {
    // CC — knobs and pitch wheel (some devices send pitch as CC)
    onMidiCC(data1, data2);
  } else if (type === 0xe0) {
    // Pitch bend — 14-bit value, combine LSB (data1) and MSB (data2)
    const value = (data2 << 7 | data1); // 0–16383, center = 8192
    const normalized = value / 16383 * 127; // scale to 0–127
    onPitchWheel(normalized);
  }
}

let pitchWheelTriggered = false; // prevent repeat trigger until wheel returns to center

function onPitchWheel(value) {
  if (value > 96) {
    if (!pitchWheelTriggered) {
      pitchWheelTriggered = true;
      const newIdx = sceneIdx + 1;
      if (!isLoading && !xfadeActive && newIdx < loadedScenes.length) {
        startSceneCrossfade(newIdx);
        sendEvent({ type: 'scene', sceneIdx: newIdx });
      }
    }
  } else if (value < 32) {
    if (!pitchWheelTriggered) {
      pitchWheelTriggered = true;
      const newIdx = sceneIdx - 1;
      if (!isLoading && !xfadeActive && newIdx >= 0) {
        startSceneCrossfade(newIdx);
        sendEvent({ type: 'scene', sceneIdx: newIdx });
      }
    }
  } else {
    // Dead zone — reset trigger
    pitchWheelTriggered = false;
  }
}

function onMidiCC(cc, value) {
  knobValues[cc] = value;

  // During knob reset phase: track confirmations, suppress all other knob actions
  if (awaitingKnobReset) {
    if (knobsToConfirm.has(cc)) {
      const fadeCC = getFadeKnobCC();
      const confirmed = (cc === fadeCC) ? value >= 64 : value < 64;
      if (confirmed) {
        knobsConfirmed.add(cc);
        updateKnobResetPrompt();
        if (knobsConfirmed.size >= knobsToConfirm.size) {
          awaitingKnobReset = false;
          awaitingEnter = true;
          initialKnobCheckDone = true;
          loadingEl.textContent = 'Press Enter or any piano key to begin';
          playReadyTone();
        }
      }
    }
    return;
  }

  evaluateKnobs(cc);
}

let lastKnobMovement = -1; // last movement selected by knobs (-1 = none forced)
let fadeKnobAboveHalf = null; // track threshold crossings for fade knob

function getKnobCCs() {
  return (masterConfig && masterConfig.config && masterConfig.config.midiKnobCCs)
    ? masterConfig.config.midiKnobCCs
    : []; // no defaults — must be set in config.json
}

function updateKnobResetPrompt() {
  const remaining = knobsToConfirm.size - knobsConfirmed.size;
  loadingEl.textContent = `Set knobs: movement knobs DOWN, fade knob (8) UP\n${remaining} knob${remaining === 1 ? '' : 's'} remaining`;
}

function getFadeKnobCC() {
  return (masterConfig && masterConfig.config && masterConfig.config.midiFadeKnobCC != null)
    ? masterConfig.config.midiFadeKnobCC
    : 83; // knob 8 on Oxygen 8
}

function evaluateKnobs(changedCC) {
  if (!masterConfig) return;
  const knobCCs = getKnobCCs();
  const fadeCC  = getFadeKnobCC();

  // Fade knob (CC 83): edge-triggered at halfway — only during active performance
  if (changedCC === fadeCC && !awaitingEnter) {
    const val = knobValues[fadeCC];
    if (val >= 64 && fadeKnobAboveHalf !== true) {
      fadeKnobAboveHalf = true;
      if (loadedScenes.length > 0) {
        fadeSceneIn();
        sendEvent({ type: 'fade', action: 'in' });
      }
    } else if (val < 64 && fadeKnobAboveHalf !== false) {
      fadeKnobAboveHalf = false;
      fadeRawOut();
      fadeSceneOut();
      sendEvent({ type: 'fade', action: 'out' });
    }
  }

  // Knob 1: start performer (Enter equivalent)
  const knob1CC = knobCCs[0];
  if (knob1CC !== undefined && knobValues[knob1CC] >= 64) {
    if (awaitingEnter) fadeSceneIn();
  }

  // Knobs 2–7: movement selection (highest past halfway wins; knob 8 reserved for fade)
  let highestMovement = -1;
  for (let i = 1; i < Math.min(knobCCs.length, 7); i++) {
    const cc = knobCCs[i];
    if (cc !== undefined && knobValues[cc] >= 64) {
      highestMovement = i;
    }
  }

  const targetMovement = highestMovement === -1 ? 0 : highestMovement;
  if (targetMovement !== lastKnobMovement && targetMovement !== movementIdx && !isLoading) {
    lastKnobMovement = targetMovement;
    loadMovement(targetMovement);
    sendEvent({ type: 'movement', movementIdx: targetMovement });
  }
}

// ============================================================
// KEYBOARD
// ============================================================
document.addEventListener('keydown', (e) => {
  if (e.repeat) return;

  const key = e.key;
  const keyL = key.toLowerCase();

  // HUD toggle (performer only)
  if (keyL === 'h' && IS_PERFORMER) {
    showHud = !showHud;
    return;
  }

  // Fullscreen (both roles)
  if (keyL === 'f') {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().then(resize);
    } else {
      document.exitFullscreen().then(resize);
    }
    return;
  }

  if (!IS_PERFORMER) return; // display role: no further input handling

  // Reload config
  if (keyL === 'r') {
    loadMasterConfig().then(() => {
      if (movementIdx >= 0) mergeConfig(movementIdx);
      buildMidiNoteMap();
      console.log('Config reloaded');
    });
    return;
  }

  // Movement switching: 1, 2, 3
  if (key === '1' || key === '2' || key === '3') {
    const idx = parseInt(key) - 1;
    if (!masterConfig || idx >= masterConfig.movements.length) return;
    if (idx === movementIdx && !isLoading) return;
    loadMovement(idx);
    sendEvent({ type: 'movement', movementIdx: idx });
    return;
  }

  // Enter = fade in from black
  if (key === 'Enter') {
    if (loadedScenes.length > 0) {
      fadeSceneIn();
      sendEvent({ type: 'fade', action: 'in' });
    }
    return;
  }

  // Escape = fade to black
  if (key === 'Escape') {
    fadeRawOut();
    fadeSceneOut();
    sendEvent({ type: 'fade', action: 'out' });
    return;
  }

  // Space = toggle raw image
  if (key === ' ') {
    if (rawFadeTarget === 0) {
      fadeRawIn();
      sendEvent({ type: 'raw', action: 'in' });
    } else {
      fadeRawOut();
      sendEvent({ type: 'raw', action: 'out' });
    }
    return;
  }

  // Left/Right arrow = crossfade between scenes (no wrap)
  if (key === 'ArrowRight') {
    if (!isLoading && !xfadeActive && sceneIdx < loadedScenes.length - 1) {
      startSceneCrossfade(sceneIdx + 1);
      sendEvent({ type: 'scene', sceneIdx: sceneIdx + 1 });
    }
    return;
  }
  if (key === 'ArrowLeft') {
    if (!isLoading && !xfadeActive && sceneIdx > 0) {
      startSceneCrossfade(sceneIdx - 1);
      sendEvent({ type: 'scene', sceneIdx: sceneIdx - 1 });
    }
    return;
  }

  // Sequence activation
  if (seqStates[keyL]) {
    physicallyHeldKeys.add(keyL);
    activateSequence(keyL);
    sendEvent({ type: 'activate', key: keyL });
    return;
  }
});

document.addEventListener('keyup', (e) => {
  if (!IS_PERFORMER) return;
  const keyL = e.key.toLowerCase();
  physicallyHeldKeys.delete(keyL);
  if (seqStates[keyL]) {
    deactivateSequence(keyL);
    sendEvent({ type: 'deactivate', key: keyL });
  }
});

document.addEventListener('contextmenu', e => e.preventDefault());
document.addEventListener('mousemove', () => { document.body.style.cursor = 'none'; });

// ============================================================
// START
// ============================================================
async function init() {
  document.body.style.cursor = 'none';
  resize();
  loadingEl.textContent = 'Loading config...';

  try {
    await loadMasterConfig();
  } catch (e) {
    loadingEl.textContent = 'Error: config.json not found.\nCreate it or start server.py first.';
    return;
  }

  buildMidiNoteMap();
  connectWebSocket();
  initMidi();
  requestWakeLock();

  requestAnimationFrame(renderLoop);
  await loadMovement(0);
}

init();
</script>
</body>
</html>
